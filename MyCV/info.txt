package main

import (
    "context"
    "fmt"
    "log"

    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

// flattenSearchValues updates the search object to have all values set to true,
// and flattens nested objects using dot notation for the keys.
func flattenSearchValues(search bson.M, prefix string) bson.M {
    flatSearch := bson.M{}
    for key, value := range search {
        // Construct new key using prefix, if provided
        newKey := key
        if prefix != "" {
            newKey = prefix + "." + key
        }

        switch v := value.(type) {
        case bson.M:
            // Recursively process nested objects
            for k, val := range flattenSearchValues(v, newKey) {
                flatSearch[k] = val
            }
        default:
            // Set value to true for non-object values
            flatSearch[newKey] = true
        }
    }
    return flatSearch
}

func upsertDocuments(collection *mongo.Collection, targetCollection *mongo.Collection) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
    defer cancel()

    // Query to find documents with "search" field
    filter := bson.M{"search": bson.M{"$exists": true}}

    cursor, err := collection.Find(ctx, filter)
    if err != nil {
        log.Fatal(err)
    }
    defer cursor.Close(ctx)

    for cursor.Next(ctx) {
        var document bson.M
        if err := cursor.Decode(&document); err != nil {
            log.Fatal(err)
        }

        if search, ok := document["search"].(bson.M); ok {
            flattenedSearch := flattenSearchValues(search, "")

            // Prepare the document for upserting with the flattened 'search' field
            update := bson.M{"$set": bson.M{"search": flattenedSearch}}
            if client, ok := document["client"]; ok {
                update["$set"].(bson.M)["client"] = client
            }
            if url, ok := document["url"]; ok {
                update["$set"].(bson.M)["url"] = url
            }

            options := options.Update().SetUpsert(true)
            _, err = targetCollection.UpdateOne(ctx, bson.M{"_id": document["_id"]}, update, options)
            if err != nil {
                log.Fatal(err)
            }
        }
    }

    if err := cursor.Err(); err != nil {
        log.Fatal(err)
    }

    fmt.Println("Documents upserted with flattened 'search'")
}

func groupByClientAndUrlAndMerge(collection *mongo.Collection) {
    ctx := context.TODO()

    pipeline := mongo.Pipeline{
        {
            {"$group": bson.D{
                {"_id", bson.D{{"client", "$client"}, {"url", "$url"}}},
                {"count", bson.D{{"$sum", 1}}},
            }},
        },
        {
            {"$merge": bson.D{
                {"into", "aggregatedResults"}, // Specify the target collection for the merge
                // Optional specifications like "on", "whenMatched", "whenNotMatched" can be added here
            }},
        },
    }

    cursor, err := collection.Aggregate(ctx, pipeline)
    if err != nil {
        log.Fatal("Aggregation error:", err)
    }
    defer cursor.Close(ctx)

    fmt.Println("Aggregation with $merge completed, documents are now in 'aggregatedResults' collection.")
}

func dropRequestCollection(db *mongo.Database) {
    ctx := context.TODO()

    err := db.Collection("request").Drop(ctx)
    if err != nil {
        log.Fatal("Error dropping 'request' collection:", err)
    }

    fmt.Println("'request' collection dropped.")
}

func main() {
    clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
    client, err := mongo.Connect(context.TODO(), clientOptions)
    if err != nil {
        log.Fatal(err)
    }

    // Ensure the database name is correct
    db := client.Database("stats")

    srcCollection := db.Collection("yourSourceCollection")
    requestCollection := db.Collection("request")

    upsertDocuments(srcCollection, requestCollection)

    // Perform aggregation with $merge into 'aggregatedResults'
    groupByClientAndUrlAndMerge(requestCollection)

    // Optionally, drop the 'request' collection after aggregation is done
    dropRequestCollection(db)
}
