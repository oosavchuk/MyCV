package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/url"
    "regexp"
    "strings"
    "time"

    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

func flattenSearchValues(data interface{}, prefix string) map[string]interface{} {
    flatSearch := make(map[string]interface{})

    // Check the type of data: if it's a map, process normally; if it's a slice, iterate over it.
    switch v := data.(type) {
    case map[string]interface{}: // Original case for handling objects
        for key, value := range v {
            newKey := key
            if prefix != "" {
                newKey = prefix + "." + key
            }
            for k, val := range flattenSearchValues(value, newKey) {
                flatSearch[k] = val
            }
        }

    case []interface{}: // Additional case for handling arrays
        for i, item := range v {
            indexedPrefix := fmt.Sprintf("%s[%d]", prefix, i)
            for k, val := range flattenSearchValues(item, indexedPrefix) {
                flatSearch[k] = val
            }
        }

    default: // Handle basic types by setting the value directly
        flatSearch[prefix] = v
    }

    return flatSearch
}

func parseQueryData(query string) (bson.M, error) {
    parsedURL, err := url.Parse(query)
    if err != nil {
        return nil, err
    }

    queryParams := parsedURL.Query()

    // Initialize an empty BSON map to hold combined search and param data
    combinedData := bson.M{}

    // Extract and unmarshal the "search" data
    if searchStr := queryParams.Get("search"); searchStr != "" {
        var searchData bson.M
        if err := json.Unmarshal([]byte(searchStr), &searchData); err != nil {
            return nil, fmt.Errorf("error parsing search data: %w", err)
        }
        for k, v := range searchData {
            combinedData[k] = v
        }
    }

    // Extract and unmarshal the "param" data
    if paramStr := queryParams.Get("param"); paramStr != "" {
        var paramData bson.M
        if err := json.Unmarshal([]byte(paramStr), &paramData); err != nil {
            return nil, fmt.Errorf("error parsing param data: %w", err)
        }
        for k, v := range paramData {
            combinedData[k] = v
        }
    }

    return combinedData, nil
}


