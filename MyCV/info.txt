package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/url"
    "regexp"
    "strings"
    "time"
    "reflect"

    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

// This function is intended to process any MongoDB query operators found,
// including $elemMatch, and to flatten the structure appropriately.
func processQueryOperators(data interface{}, parentKey string) bson.M {
    flat := bson.M{}

    switch v := data.(type) {
    case map[string]interface{}:
        for key, value := range v {
            fullKey := parentKey
            if parentKey != "" {
                fullKey += "."
            }
            fullKey += key

            if key == "$elemMatch" {
                // For $elemMatch, process the nested map and append its fields to the parent key
                nestedFlat := processQueryOperators(value, "")
                for nestedKey, nestedVal := range nestedFlat {
                    compositeKey := parentKey + "." + nestedKey
                    flat[compositeKey] = nestedVal
                }
            } else {
                // Recursively process other keys
                for nestedKey, nestedVal := range processQueryOperators(value, fullKey) {
                    flat[nestedKey] = nestedVal
                }
            }
        }

    case []interface{}:
        // Process each item in the slice
        for i, item := range v {
            indexedKey := parentKey + fmt.Sprintf("[%d]", i)
            for nestedKey, nestedVal := range processQueryOperators(item, indexedKey) {
                flat[nestedKey] = nestedVal
            }
        }

    default:
        // If not a map or slice, set the value directly
        flat[parentKey] = true
    }

    return flat
}

// flattenSearchValues takes an interface{} and a prefix string, returning a bson.M.
// It recursively flattens nested maps and arrays into a flat bson.M structure with dot-notated keys.
func flattenSearchValues(data interface{}, prefix string) bson.M {
    flatSearch := bson.M{}

    reflectData := reflect.ValueOf(data)
    switch reflectData.Kind() {
    case reflect.Map:
        for _, key := range reflectData.MapKeys() {
            val := reflectData.MapIndex(key)
            cleanKey := ReplaceUdollar(key.String())
            newKey := cleanKey
            if prefix != "" {
                newKey = prefix + "." + cleanKey
            }

            // Recursive call for nested maps
            if val.Kind() == reflect.Map || val.Kind() == reflect.Slice {
                for subKey, subVal := range flattenSearchValues(val.Interface(), newKey) {
                    flatSearch[subKey] = subVal
                }
            } else {
                flatSearch[newKey] = val.Interface()
            }
        }

    case reflect.Slice:
        for i := 0; i < reflectData.Len(); i++ {
            indexedPrefix := fmt.Sprintf("%s[%d]", prefix, i)
            item := reflectData.Index(i).Interface()
            // Recursive call for items in the slice if they are maps or slices themselves
            if reflect.ValueOf(item).Kind() == reflect.Map || reflect.ValueOf(item).Kind() == reflect.Slice {
                for subKey, subVal := range flattenSearchValues(item, indexedPrefix) {
                    flatSearch[subKey] = subVal
                }
            } else {
                flatSearch[indexedPrefix] = item
            }
        }
    default:
        // Basic types are directly assigned
        flatSearch[prefix] = data
    }

    return flatSearch
}

func parseQueryData(query string) (bson.M, error) {
    parsedURL, err := url.Parse(query)
    if err != nil {
        return nil, err
    }

    queryParams := parsedURL.Query()

    // Initialize an empty BSON map to hold combined search and param data
    combinedData := bson.M{}

    // Extract and unmarshal the "search" data
    if searchStr := queryParams.Get("search"); searchStr != "" {
        var searchData bson.M
        if err := json.Unmarshal([]byte(searchStr), &searchData); err != nil {
            return nil, fmt.Errorf("error parsing search data: %w", err)
        }
        for k, v := range searchData {
            combinedData[k] = v
        }
    }

    // Extract and unmarshal the "param" data
    if paramStr := queryParams.Get("param"); paramStr != "" {
        var paramData bson.M
        if err := json.Unmarshal([]byte(paramStr), &paramData); err != nil {
            return nil, fmt.Errorf("error parsing param data: %w", err)
        }
        for k, v := range paramData {
            combinedData[k] = v
        }
    }

    return combinedData, nil
}


