package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/url"
    "regexp"
    "strings"
    "time"
    "reflect"

    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

// flattenSearchValues takes an interface{} and a prefix string, returning a bson.M.
// It recursively flattens nested maps and arrays into a flat bson.M structure with dot-notated keys.
func flattenSearchValues(data interface{}, prefix string) bson.M {
    flatSearch := bson.M{}

    reflectData := reflect.ValueOf(data)
    switch reflectData.Kind() {
    case reflect.Map:
        for _, key := range reflectData.MapKeys() {
            val := reflectData.MapIndex(key)
            cleanKey := ReplaceUdollar(key.String())
            newKey := cleanKey
            if prefix != "" {
                newKey = prefix + "." + cleanKey
            }

            // Recursive call for nested maps
            if val.Kind() == reflect.Map || val.Kind() == reflect.Slice {
                for subKey, subVal := range flattenSearchValues(val.Interface(), newKey) {
                    flatSearch[subKey] = subVal
                }
            } else {
                flatSearch[newKey] = val.Interface()
            }
        }

    case reflect.Slice:
        for i := 0; i < reflectData.Len(); i++ {
            indexedPrefix := fmt.Sprintf("%s[%d]", prefix, i)
            item := reflectData.Index(i).Interface()
            // Recursive call for items in the slice if they are maps or slices themselves
            if reflect.ValueOf(item).Kind() == reflect.Map || reflect.ValueOf(item).Kind() == reflect.Slice {
                for subKey, subVal := range flattenSearchValues(item, indexedPrefix) {
                    flatSearch[subKey] = subVal
                }
            } else {
                flatSearch[indexedPrefix] = item
            }
        }
    default:
        // Basic types are directly assigned
        flatSearch[prefix] = data
    }

    return flatSearch
}

func parseQueryData(query string) (bson.M, error) {
    parsedURL, err := url.Parse(query)
    if err != nil {
        return nil, err
    }

    queryParams := parsedURL.Query()

    // Initialize an empty BSON map to hold combined search and param data
    combinedData := bson.M{}

    // Extract and unmarshal the "search" data
    if searchStr := queryParams.Get("search"); searchStr != "" {
        var searchData bson.M
        if err := json.Unmarshal([]byte(searchStr), &searchData); err != nil {
            return nil, fmt.Errorf("error parsing search data: %w", err)
        }
        for k, v := range searchData {
            combinedData[k] = v
        }
    }

    // Extract and unmarshal the "param" data
    if paramStr := queryParams.Get("param"); paramStr != "" {
        var paramData bson.M
        if err := json.Unmarshal([]byte(paramStr), &paramData); err != nil {
            return nil, fmt.Errorf("error parsing param data: %w", err)
        }
        for k, v := range paramData {
            combinedData[k] = v
        }
    }

    return combinedData, nil
}


